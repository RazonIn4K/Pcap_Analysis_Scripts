# !/usr/bin/env python3
import re
import os
import json
from ..core.command import run_command
from ..core.utils import calculate_entropy

def detect_dns_tunneling(pcap_file, threshold=0.8, time_filter=""):
    """Detect potential DNS tunneling by analyzing DNS query entropy and length"""
    print("\n=== Potential DNS Tunneling Detection ===")
    
    # Extract DNS queries
    dns_queries = run_command(
        f"tshark -r {pcap_file} -Y \"dns.qry.name{time_filter}\" -T fields -e dns.qry.name"
    )
    
    if not dns_queries:
        print("No DNS queries found")
        return None
    
    # Analyze DNS query entropy and length
    high_entropy_queries = []
    long_queries = []
    
    for query in dns_queries.strip().split('\n'):
        if not query:
            continue
            
        # Calculate entropy of the query
        entropy = calculate_entropy(query)
        
        # Check for high entropy (potential encoded data)
        if entropy > threshold:
            high_entropy_queries.append((query, entropy))
            
        # Check for unusually long queries
        if len(query) > 50:  # Threshold for long DNS queries
            long_queries.append((query, len(query)))
    
    # Print results
    if high_entropy_queries:
        print("\n-- High Entropy DNS Queries (Possible Data Exfiltration) --")
        for query, entropy in high_entropy_queries[:20]:  # Limit to top 20
            print(f"Query: {query} | Entropy: {entropy:.4f}")
    else:
        print("No high entropy DNS queries detected")
        
    if long_queries:
        print("\n-- Unusually Long DNS Queries --")
        for query, length in sorted(long_queries, key=lambda x: x[1], reverse=True)[:20]:
            print(f"Query: {query} | Length: {length}")
    else:
        print("No unusually long DNS queries detected")
    
    # Check for high volume of DNS queries from same source
    dns_volume = run_command(
        f"tshark -r {pcap_file} -Y \"dns.qry.name{time_filter}\" -T fields -e ip.src -e dns.qry.name | "
        f"sort | uniq -c | sort -nr | head -n 20"
    )
    print("\n-- DNS Query Volume by Source --")
    print(dns_volume or "No DNS query volume data available")
    
    return {
        "high_entropy_queries": high_entropy_queries,
        "long_queries": long_queries,
        "dns_volume": dns_volume
    }

def detect_c2_traffic(pcap_file, time_filter=""):
    """Detect potential command and control (C2) traffic"""
    print("\n=== Potential Command & Control (C2) Traffic ===")
    
    # Look for unusual destination ports
    unusual_ports = run_command(
        f"tshark -r {pcap_file} -Y \"!tcp.port==80 and !tcp.port==443 and !tcp.port==53 and "
        f"!udp.port==53{time_filter}\" -T fields -e ip.src -e ip.dst -e tcp.dstport -e udp.dstport | "
        f"sort | uniq -c | sort -nr | head -n 20"
    )
    print("-- Unusual Destination Ports --")
    print(unusual_ports or "No unusual destination ports detected")
    
    # Check for encrypted traffic patterns
    encrypted_traffic = run_command(
        f"tshark -r {pcap_file} -Y \"ssl or tls{time_filter}\" -T fields -e ip.src -e ip.dst -e tcp.dstport | "
        f"sort | uniq -c | sort -nr | head -n 20"
    )
    print("\n-- Encrypted Traffic Patterns --")
    print(encrypted_traffic or "No encrypted traffic patterns detected")
    
    # Check for periodic beaconing (regular intervals between packets)
    beaconing = run_command(
        f"tshark -r {pcap_file} -q -z io,stat,60 | grep -v \"60.000000\""
    )
    print("\n-- Potential Beaconing Activity (60s intervals) --")
    print(beaconing or "No obvious beaconing activity detected")
    
    # Check for malware-related patterns
    malware_patterns = run_command(
        f"tshark -r {pcap_file} -Y \"(dns.qry.name contains \\\"bit\\\" or "
        f"dns.qry.name contains \\\"onion\\\" or "
        f"dns.qry.name contains \\\"long\\\") or "
        f"(http.user_agent contains \\\"MSIE\\\" and http.request.version != \\\"HTTP/1.1\\\") or "
        f"(tcp.flags == 0x02 and tcp.window_size <= 1024){time_filter}\" "
        f"-T fields -e frame.time -e ip.src -e ip.dst -e dns.qry.name -e http.user_agent | head -n 20"
    )
    print("\n-- Potential Malware Communication --")
    print(malware_patterns or "No suspicious malware traffic patterns detected")
    
    return {
        "unusual_ports": unusual_ports,
        "encrypted_traffic": encrypted_traffic,
        "beaconing": beaconing,
        "malware_patterns": malware_patterns
    }

def detect_data_exfiltration(pcap_file, size_threshold=1000000, time_filter=""):
    """Detect potential data exfiltration based on large data transfers"""
    print("\n=== Potential Data Exfiltration ===")
    
    # Look for large data transfers
    large_transfers = run_command(
        f"tshark -r {pcap_file} -q -z conv,ip | sort -k 9nr | head -n 20"
    )
    print("-- Large Data Transfers --")
    print(large_transfers or "No large data transfers detected")
    
    # Check for unusual protocols with large data transfers
    unusual_protocols = run_command(
        f"tshark -r {pcap_file} -Y \"!http and !dns and !ssl and !tls and frame.len > 1000{time_filter}\" "
        f"-T fields -e frame.number -e ip.src -e ip.dst -e frame.len -e frame.protocols | "
        f"sort -k 4nr | head -n 20"
    )
    print("\n-- Unusual Protocols with Large Transfers --")
    print(unusual_protocols or "No unusual protocols with large transfers detected")
    
    # Check for data uploads (outbound traffic)
    data_uploads = run_command(
        f"tshark -r {pcap_file} -q -z io,stat,0,\"ip.src==INTERNAL_IP and ip.dst!=INTERNAL_IP\""
    ).replace("INTERNAL_IP", "192.168.0.0/16")  # Replace with actual internal IP range
    
    print("\n-- Outbound Data Transfers (Replace INTERNAL_IP with your network range) --")
    print(data_uploads or "No significant outbound data transfers detected")
    
    return {
        "large_transfers": large_transfers,
        "unusual_protocols": unusual_protocols,
        "data_uploads": data_uploads
    }

def check_known_bad_hosts(pcap_file, ioc_file=None):
    """Check for communication with known malicious hosts"""
    print("\n=== Communication with Known Malicious Hosts ===")
    
    if ioc_file and os.path.exists(ioc_file):
        try:
            with open(ioc_file, 'r') as f:
                iocs = json.load(f)
                
            # Extract IP addresses and domains
            bad_ips = iocs.get('ip_addresses', [])
            bad_domains = iocs.get('domains', [])
            
            # Create filter expressions
            ip_filter = " or ".join([f"ip.addr == {ip}" for ip in bad_ips]) if bad_ips else ""
            domain_filter = " or ".join([f"dns.qry.name contains \"{domain}\"" for domain in bad_domains]) if bad_domains else ""
            
            # Combine filters
            combined_filter = ""
            if ip_filter and domain_filter:
                combined_filter = f"({ip_filter}) or ({domain_filter})"
            elif ip_filter:
                combined_filter = ip_filter
            elif domain_filter:
                combined_filter = domain_filter
                
            if combined_filter:
                # Check for matches
                matches = run_command(
                    f"tshark -r {pcap_file} -Y \"{combined_filter}\" -T fields -e frame.number -e ip.src -e ip.dst -e dns.qry.name"
                )
                
                if matches:
                    print("-- Matches Found --")
                    print(matches)
                else:
                    print("No communication with known bad hosts detected")
            else:
                print("No IOCs provided in the file")
                
        except json.JSONDecodeError:
            print(f"Error: {ioc_file} is not a valid JSON file")
    else:
        print("No IOC file provided or file does not exist")
        
        # Fallback to checking against common malware domains/IPs
        common_check = run_command(
            f"tshark -r {pcap_file} -Y \"dns.qry.name contains 'malware' or dns.qry.name contains 'phish' or "
            f"dns.qry.name contains 'botnet'\" -T fields -e frame.number -e ip.src -e dns.qry.name"
        )
        
        if common_check:
            print("-- Suspicious Domain Matches --")
            print(common_check)
        else:
            print("No matches against common suspicious domains")
    
    return None  # Return value depends on implementation details 